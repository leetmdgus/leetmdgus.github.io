---
title: "[C++] 인라인 함수를 배워보자..."
description: "[C++] 인라인 함수를 배워 보자..."
tags: 
 - "C++"
 - "객체지향"
 - "프로그래밍언어"
feedback: false
---
## 인라인(inline) 함수

+ 인라인 함수를 의역해 보면, '프로그램 코드 안으로 들어가 버린 함수'라는 뜻이 된다.



#### 매크로 함수

+ C언어에서는 #define 선행처리 지시문에 인수로 함수의 정의를 전달함으로써, 함수처럼 동작하는 매크로를 만들 있다.
+ 다음 예제는 SUB(X, Y)와 PRT(X)라는 매크로 함수를 정의하고 사용하는 예제이다.

~~~c++
#include <stdio.h>
#define SUB(X,Y) X-Y
#define PRT(X) printf("계산 결과는 %d입니다.\n", X)

int main(void){
    int result;
    int num_01 = 15, num_02 = 7;  
    
    result = SUB(num_01, num_02);
    PRT(result);
    return 0;
}  
~~~

> 실행 결과

~~~
계산 결과는 8입니다.
~~~



+ 매크로 함수는 일반 함수와는 달리 단순 치환만을 해주므로, 일반 함수와 완전히 똑같은 방식으로 동작하지는 않는다.
+ 다음은 일반 함수와 매크로 함수와의 차이를 보여주는 예제이다.

```c++
#include <stdio.h>
#define SQR(X) X*X
#define PRT(X) printf("계산 결과는 %d입니다.\n", X)  

int main(void){
    int result;
    int x = 5;  
    
    result = SQR(10);
    PRT(result);
    result = SQR(x);
    PRT(result);
    result = SQR(x+3);
    PRT(result);
    return 0;
}  
```

> 실행 결과

~~~
계산 결과는 100입니다.
계산 결과는 25입니다.
계산 결과는 23입니다.
~~~

+ 위의 예제에서 맨 마지막의 매크로 함수는 예상한 결과와는 전혀 다른 결괏값을 반환합니다.

  선행처리기는 매크로 정의에서 모든 X를 X+3으로 대체합니다.

  따라서 SQR(x+3)은 다음과 같이 대체되어 계산됩니다.

  x+3*x+3 = 5+3*5+3 = 5+15+3 = 23

+ 일반 함수는 인수를 프로그램이 실행 중일 때 전달받지만, 매크로 함수는 인수를 컴파일 이전에 미리 치환하기 때문입니다.

  따라서 이와 같은 오류를 미리 방지하기 위해서는 다음 예제의 ①번 코드처럼 각 인수를 모두 괄호(())로 묶어줘야 합니다.



#### 매크로 함수를 사용할 때의 주의

+ 매크로 함수의 전체를 괄호(())로 감싸야 합니다.

+ 매크로 함수의 인수들도 각각 괄호로 감싸야 합니다.

+ 매크로 함수를 호출할 때에는 증감 연산자(++, --)나 복합 대입 연산자 등은 사용하지 않는 것이 좋습니다.



#### 매크로 함수의 장점

+ 일반적인 함수에 비해서 실행속도의 이점이 있다.



#### 매크로 함수의 단점

+ 정의하기가 어렵다. 복잡한 함수를 매크로의 형태로 정의하는데 한계가 잇다.



#### 매크로 함수 정의

~~~~c++
#incldue <iostream>
#define SQUARE(x) ((x)*(x))

int main(void){
	std::cout<< SQUARE(5)<<std::endl;
	return 0;
}
~~~~

위의 코드는 전처리 과정을 거치면 다음과 같이 변경된다.

~~~
#incldue <iostream>

int main(void){
	std::cout<<((5)*(5)) <<std::endl;
	return 0;
}
~~~

+ 위예제와 같이 함수의 몸체부분이 함수 호출 문장을 완전히 대체했을 때, '함수가 인라인화 되었다.'라고 표현한다.
+ 이러한 매크로 함수의 장점은 유지하되, 단점은 제가하는 방법을 C++에서는 제공한다.



#### C++ 기반의 인라인 함수 정의

~~~c++
#include <iostream>

inline int SQUARE(int x){
	return x*x;
}
int main(void){
	std::cout << SQUARE(5) <<std::endl;
	std::cout << SQUARE(12) <<std::endl;
	return 0;
}
~~~

> 실행결과

~~~
24
144
~~~

+ 매크로를 이용한 함수의 인라인화는 전처리기에 의해 처리되지만, 키워드 inline을 통한 함수의 인라인화는 컴파일러에 의해 처리가 된다. 
+ 따라서 컴파일러는 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우, 이 키워드를 무시해버리기도 한다. 
+ 또한 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.



#### 매크로 함수에는 있지만, 인라인 함수에는 없는 장점

+ 사실 위의 인라인 함수는 매크로 함수의 장점을 완전히 대체하지 못했다. 예를 들어 매크로 함수가 다음과 같이 정의되면,

```c++
#define SQUARE(x) ((x)*(x))
```

+ 이는 자료형에 의존적이지 않은 함수가 된다. 따라서 다음의 함수 호출 문장은

```
std::cout<<SQUARE(12);  
std::cout<<SQUARE(3.15); 
```

+ 다음과 같이 변황니 이루어져서 **어떠한 경우에도 데이터 손실**이 발생하지 않는다.

~~~C++
std::cout<<SQUARE((12)*(12));    // 인트형 함수 호출
std::cout<<SQUARE((3.15)*(3.15));  //더블형 함수 호출
~~~

+ 하지만, 다음과  같이 정의된 인라인 함수는

~~~c++
inline int SQUARE(int x){retusn x*x}
~~~

+ int형 기반으로 정의된 함수이기 때문에 다음의 함수 호출 문장에서 데이터 손실이 발생한다.

```C++
std::cout<<SQUARE(3.15); //0.15가 손실되어서 3*3의 결과인 9가 출력
```

+ 함수의 오버로딩을 통해서 이 문제를 해결할 수 있으나, 여러개의 함수를 추가로 정의하는 꼴이 되어, 한번만 정의하면 되는 매크로 함수의 장점과는 거리가 멀어지게 된다. 
+ C++의 템플릿이라는 것을 이용하면 매크로 함수와 마찬가지로 자료형에 의존적이지 않은 함수가 완성된다. 



#### 템플릿 예시

오늘은 간단한 예만 확인하겠다.

~~~C++
#include <iostream>

template <typename T>
inline T SQUARE( T x ){
	return x*x;
}

int main(void){
	std::cout << SQUARE(5,5)<<std::endl;
	std::cout << SQUARE(12)<<std::endl;
	return 0;
}
~~~

+ 위 코드를 실행해보면, 데이터의 손실이 발생하지 않았음을 알 수 있다.



오늘은 인라인함수에 대해 배워보았다. 

오늘 내용은 잘 이해가 가지 않아 한 번 더 복습해야할 필요가 있을 것 같다.



제작일 : 2020-10-15

<참고 : 열혈 C++ 프로그래밍 , TCP school.com>